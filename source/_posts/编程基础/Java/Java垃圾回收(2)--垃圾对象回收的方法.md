---
title: Java垃圾回收(2)--垃圾对象回收的方法
date: 2014-09-09 16:48:05
tags: [JAVA]
categories: [编程基础]
---
上篇文章简述了JVM GC的第一个阶段，垃圾对象的判别方法（使用可达性分析法找到所有存活的对象），本篇简要说明下GC的下一个阶段：对象回收的方法。

## 清除（sweep）
清除算法最为简单，直接将垃圾对象所占内存标记为空闲内存（JVM会维护一个空闲列表），当需要为新创建对象分配内存时，内存管理模块会从空闲内存中寻址内存，并分配给新创建的对象。

#### 缺点
该方法维护了一个“空闲列表”，意味着增加了对象分配的开销。

一是会造成内存碎片。由于JVM堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。
另一个则是分配效率较低。如果是一块连续的内存空间，那么我们可以通过指针加法（pointer bumping）来做分配。而对于空闲列表，Java 虚拟机则需要逐个访问列表中的项，来查找能够放入新建对象的空闲内存。
每当进行扫描时，JVM必须确保可以重用填充了无法访问的对象的区域。 这可能（并最终会）导致内存碎片，与磁盘碎片类似，会导致两个问题：
写操作变得更加耗时，因为找到足够大小的下一个空闲块不再是一个简单的操作。
 因此，如果碎片升级到没有单个空闲片段足以容纳新创建的对象的点，则会发生分配错误。
为避免此类问题，JVM确保碎片不会失控。 因此，垃圾收集过程中也会发生“内存碎片整理”过程，而不仅仅是标记和扫描。 此过程将所有可到达对象重新定位到彼此旁边，从而消除（或减少）碎片。 这是一个例子：


可能存在大量的自由区域但是如果没有单个区域足够大以容纳分配，则分配仍将失败（在Java中具有OutOfMemoryError）。

![](https://plumbr.io/wp-content/uploads/2015/06/GC-sweep.png)




第二种是压缩（compact），即把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。



第三种则是复制（copy），即把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到 to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。复制这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。
